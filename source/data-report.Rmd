---
title: "Telecommunication Customer Churn Analysis"
output: word_document
---

## Authors 
Ali El-Sharif, Neha Panchal, Sagnik Adusumilli, Sarmad Shubber

## Background
 Nowadays, the telecom industry faces fierce competition in satisfying its customers. When a business loses customers, its profit and growth rate may be negatively affected. The churn rate of a company is percentage of subscribers to a service who discontinue their subscriptions within a given time period. 

## Objective
We will create a system that groups customers by their traits to better serve their individual needs.

## Data Analysis
The data has been sourced from Kaggle https://www.kaggle.com/jpacse/datasets-for-churn-telecom
The dataset is preprocessed and a balanced consisting of 71,047 instances and 58 attributes.

## Data Dictionary
Column Name               | Column Description  
--------------------------| ------------------- 
CustomerID	              | Unique customer ID
Churn	                    | Customer cut ties with service during a given time period (Yes/No)
MonthlyRevenue	          | Monthly revenue
MonthlyMinutes	          | Mean monthly minute of use
TotalRecurringCharge      | Mean total recurring charge
DirectorAssistedCalls     | Mean number of director assisted calls
OverageMinutes	          | Mean overage minute of use
RoamingCalls	            | Number of call were made and received outside of home area network operator
PercChangeMinutes	        | % change in minute of use
PercChangeRevenues        | % change in revenues
DroppedCalls	            | Number of telephone calls which, due to technical reasons were cut off
BlockedCalls	            | Number of incoming subscriber's blocked calls from specific telephone numbers
UnansweredCalls	          | Number of calls which are not picked up by an agent
CustomerCareCalls	        | Number of calls made by customer care to the subscriber.
ThreewayCalls	            | Number of conference call with two other two callers with local numbers
ReceivedCalls	            | Number of incoming calls that were answered
OutboundCalls	            | Number of  call initiated by a call center agent to a customer
InboundCalls	            | Number of call initiated by a  customer to call center agent
PeakCallsInOut	          | Mean of peak in and out voice calls
OffPeakCallsInOut	        | Mean number of in and out off peak voice calls
DroppedBlockedCalls	      | Mean number of dropped blocked calls
CallForwardingCalls	      | Number of redirected calls to another available telephone numbers
CallWaitingCalls	        | Number of suspended calls already in progress to accept a second call
MonthsInService	          | Months in Service
UniqueSubs	              | Number of unique subs
ActiveSubs	              | Number of active subs
ServiceArea	              | Area covered by the signal of a broadcasting station
Handsets	                | Outer part of mobile phone that does not include the battery or the sim card
HandsetModels	            | Models of mobile phones
CurrentEquipmentDays      | Number of days of the current equipment
AgeHH1	                  | Age of first HH member
AgeHH2	                  | Age of second HH member
ChildrenInHH	            | Presence of children in HH (Yes/No)
HandsetRefurbished	      | Pre-owned handset sent back due to a fault and has been repaired for re-sale (Yes/No)
HandsetWebCapable	        | Handset is web capable (Yes/No)
TruckOwner	              | Subscriber owns a Truck (Yes/No)
RVOwner	                  | Subscriber owns a recreational vehicle (Yes/No)
Homeownership	            | Subscriber owns a home (Yes/No)
BuysViaMailOrder	        | Buys via mail order (Yes/No)
RespondsToMailOffers  	  | Number of time Subscriber responds to a mail offers (Yes/No)
OptOutMailings	          | Chosen by not to be solicited by Mails (Yes/No)
NonUSTravel	              | Rravelled to non-US country (Yes/No)
OwnsComputer	            | Owns a personal computer (Yes/No)
HasCreditCard	            | Has a credit card (Yes/No)
RetentionCalls	          | Customer  made call to retention team
RetentionOffersAccepted   | Number of previous retention offers accepted
NewCellphoneUser	        | Known to be a new cell phone user	(Yes/No)
NotNewCellphoneUser	      | Known not to be a new cell phone user (Yes/No)
ReferralsMadeBySubscriber	| Number of referals made by subscriber
IncomeGroup	              | Subscriber income group
OwnsMotorcycle	          | Subscriber owns a	motor cycle (Yes/No)
AdjustmentsToCreditRating	| Number of adjustments were made to customer's credit rating (Up or Down)
HandsetPrice	            | Price of outer part of mobile phone not including  battery or sim card
MadeCallToRetentionTeam	  | Number of calls were made to retention team	(Yes/No)
CreditRating	            | Credit Rating
PrizmCode	                | PRIZM (Potential Rating Index for Zip Market) - census data market segmentation
Occupation	              | Occupation
MaritalStatus             | Marital status

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#import packages;
library(dplyr)
library(reshape2)
library(ggplot2)
library(Hmisc)
library(corrplot)
library(mice)
library(VIM)
library(pROC)
library(caret)
library(sqldf)

# Clean all variables that might be left by other scripts
rm(list=ls(all=TRUE))

```


```{r, include=FALSE}
# Read data
telecomData = read.csv("../data/cell2celltrain.csv", header = TRUE, na.strings =  c("NA","","#NA"), sep=",")

```
## Data Exploartion
Summary:
```{r, echo = FALSE, warning = FALSE, message = FALSE}
summary(telecomData)

```
Structure:
```{r, echo = FALSE, warning = FALSE, message = FALSE}
str(telecomData)

```

Creating a correlation matrix
```{r fig.width=10, fig.height=10, echo = FALSE, warning = FALSE, message = FALSE}
# we can only Create a correlation matrix with only numeric data, therefore we are going to use sapply to only get numeric data
# sapply is applying a fuction over list of vector
numericData <- telecomData[sapply(telecomData,is.numeric)]
matrix <- cor(numericData, use="pairwise.complete.obs")
corrplot(matrix, type = "lower", method = "circle", order="hclust", tl.srt = 45, tl.cex = 0.7)
```

## Missing Data
```{r, echo = FALSE, warning = FALSE, message = FALSE}
#lets check missing values

sort(colSums(is.na(telecomData)), decreasing = T)

#library(dplyr)
#filter(df, Total.Amount > 1000) #filter

```
Columns with NA: 
MonthlyRevenue, MonthlyMinutes, TotalRecurringCharge, DirectorAssistedCalls, OverageMinutes, RoamingCalls, PercChangeMinutes, PercChangeRevenues, Handsets, HandsetModels, CurrentEquipmentDays, AgeHH1, AgeHH2.

The maximum number of records with NA columns is 909 for columns AgeHH1 and AgeHH2. We are going to eliminate these rows with NA values.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
#We can skip all the data with missing values:
telecomData <- na.omit(telecomData)
```
After running the na.omit command, number of rows was 51,047 and now it is 49,752 rows.

Convert factor columns to numeric in order to do the clustering.
```{r, echo = FALSE, warning = FALSE, message = FALSE}
# Convert Factor columns to numeric columns
for (i in colnames(telecomData)){
  if (is.factor(telecomData[,c(i)])){
    telecomData[,c(i)] <- as.numeric(telecomData[,c(i)])
  }
}
#head(telecomData)
remove(i)
```

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, results='asis'}
#options(xtable.floating = TRUE)
#options(xtable.timestamp = "")
#options(xtable.comment = FALSE)

#summary(telecomData[,1:8])
#library(xtable)
#print(xtable(summary(telecomData[,1:8])), type="html", include.rownames = FALSE, scalebox=.7)
#print(xtable(summary(telecomData[,9:16])), include.rownames = FALSE, scalebox=.7)
#print(xtable(summary(telecomData[,17:23]), caption = "\\tt Weather Obesrvations Data Summary", label = "data_head"), include.rownames = FALSE, scalebox=.7)
```
\newpage
```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, results='asis'}
#print(xtable(telecomData[1:10,1:12]), scalebox=.6)
#print (xtable(telecomData[1:10,13:23], caption = "\\tt Telecom Obesrvations Data Sample", label = "data_head"), include.rownames = F, scalebox = .6)
```

```{r feature_distribution, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center", fig.cap=" Distribution of Important Features"}

tmp = telecomData %>%filter(complete.cases(.))

library(RColorBrewer) # color palettes
# pick palettes 
mainPalette = brewer.pal(8,"Dark2")

p1 = tmp %>% ggplot(aes(x=DirectorAssistedCalls  )) + geom_density(fill=mainPalette[1], colour=mainPalette[1], alpha = 0.2) + scale_x_log10()

p2 = tmp %>% ggplot(aes(x=RoamingCalls  )) + geom_density(fill=mainPalette[2], colour=mainPalette[2], alpha = 0.2) + scale_x_log10()

p3 = tmp %>% ggplot(aes(x=DroppedCalls  )) + geom_density(fill=mainPalette[3], colour=mainPalette[3], alpha = 0.2) + scale_x_log10()

p4 = tmp %>% ggplot(aes(x=BlockedCalls  )) + geom_density(fill=mainPalette[4], colour=mainPalette[4], alpha = 0.2) + scale_x_log10()

p5 = tmp %>% ggplot(aes(x=UnansweredCalls  )) + geom_density(fill=mainPalette[5], colour=mainPalette[5], alpha = 0.2) + scale_x_log10()

p6 = tmp %>% ggplot(aes(x=CustomerCareCalls  )) + geom_density(fill=mainPalette[6], colour=mainPalette[6], alpha = 0.2) + scale_x_log10()

p7 = tmp %>% ggplot(aes(x=ThreewayCalls  )) + geom_density(fill=mainPalette[7], colour=mainPalette[7], alpha = 0.2) + scale_x_log10()

p8 = tmp %>% ggplot(aes(x=ReceivedCalls  )) + geom_density(fill=mainPalette[8], colour=mainPalette[8], alpha = 0.2) + scale_x_log10()

p9 = tmp %>% ggplot(aes(x=OutboundCalls  )) + geom_density(fill=mainPalette[1], colour=mainPalette[1], alpha = 0.2) + scale_x_log10()

p10 = tmp %>% ggplot(aes(x=InboundCalls  )) + geom_density(fill=mainPalette[2], colour=mainPalette[2], alpha = 0.2) + scale_x_log10()

p11 = tmp %>% ggplot(aes(x=PeakCallsInOut  )) + geom_density(fill=mainPalette[3], colour=mainPalette[3], alpha = 0.2) + scale_x_log10()

p12 = tmp %>% ggplot(aes(x=OffPeakCallsInOut  )) + geom_density(fill=mainPalette[4], colour=mainPalette[4], alpha = 0.2) + scale_x_log10()

p13 = tmp %>% ggplot(aes(x=DroppedBlockedCalls  )) + geom_density(fill=mainPalette[5], colour=mainPalette[5], alpha = 0.2) + scale_x_log10()

p14 = tmp %>% ggplot(aes(x=CallForwardingCalls  )) + geom_density(fill=mainPalette[6], colour=mainPalette[6], alpha = 0.2) + scale_x_log10()

p15 = tmp %>% ggplot(aes(x=CallWaitingCalls  )) + geom_density(fill=mainPalette[7], colour=mainPalette[7], alpha = 0.2) + scale_x_log10()

p16 = tmp %>% ggplot(aes(x=RetentionCalls  )) + geom_density(fill=mainPalette[8], colour=mainPalette[8], alpha = 0.2) + scale_x_log10()

#p7 = tmp %>% ggplot(aes(x=ThreewayCalls  )) + geom_density(fill=mainPalette[7], colour=mainPalette[7], alpha = 0.2) + scale_x_log10()

#p8 = tmp %>% ggplot(aes(x= CreditRating, colour = CreditRating, fill = CreditRating  )) +
#  geom_density(alpha = 0.2) + theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position="none")

#p9 = tmp %>% ggplot(aes(x=MadeCallToRetentionTeam  )) + geom_bar(fill=mainPalette[8], colour=mainPalette[8], alpha = 0.5)

library(gridExtra) # arrange grids

grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8)
grid.arrange(p9,p10,p11,p12,p13,p14,p15,p16)

rm(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,tmp)
```



## Insights from Data explorations

## Data Preparation

# create normalization function and apply to the data
normalize <-function(x){
  return ((x-min(x))/(max(x)-min(x)))
}
telecomData_n <- as.data.frame(lapply(telecomData,normalize))

# apply R's z-score standarization function to the data
telecomData_z <-as.data.frame(lapply(telecomData,scale))

# create and apply threshold function
threshold <- function(x,c) {
  return (ifelse(x > c,1,0))
}
threshold_b <- as.data.frame(lapply(telecomData, threshold, c=1))


## Data Imputing

## Feature Selection

## Modeling

```{r, echo = FALSE, warning = FALSE, message = FALSE}
telecomDataSmall <- telecomData[1:10000,]
#scale the variables
scaled_telecomDataSmall <- scale(telecomDataSmall)

#Hierarchical Clustering
d <- dist(scaled_telecomDataSmall,method = "euclidean") #distance matrix
h_clust <- hclust(d, method = "ward") #clustering
#h_clust
plot(h_clust,labels = telecomDataSmall$CustomerID) #dendrogram

rect.hclust(h_clust,k=4)

#extract clusters
groups <- cutree(h_clust,k=4)
#groups

#pca
pcmp <- princomp(scaled_telecomDataSmall)
pred_pc <- predict(pcmp, newdata=scaled_telecomDataSmall)[,1:2]
#pred_pc
comp_dt <- cbind(as.data.table(pred_pc),cluster = as.factor(groups), Labels = telecomDataSmall$CustomerID)
#comp_dt
ggplot(comp_dt,aes(Comp.1,Comp.2))+
  geom_point(aes(color = cluster),size=3) #+xlab('x')+ylab('density')

#kmeans
kclust <- kmeans(scaled_telecomDataSmall,centers = 4,iter.max = 100)
#kclust
ggplot(comp_dt,aes(Comp.1,Comp.2))+
  geom_point(aes(color = as.factor(kclust$cluster)),size=3)

library(fpc)
tunek <- kmeansruns(scaled_telecomDataSmall,krange = 1:5,criterion = "ch")
tunek$bestk #3
#tunek$crit
#tunek
tunekw <- kmeansruns(scaled_telecomDataSmall,krange = 1:3,criterion = "asw")
tunekw$bestk #4
#tunek$size
#tunekw
```